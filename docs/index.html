<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Universal Multi-Stream Speed Detection</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }
  
  :root {
    --primary: #2962ff;
    --secondary: #00c853;
    --danger: #ff5252;
    --dark: #121212;
    --darker: #0a0a0a;
    --light: #f5f5f5;
    --gray: #424242;
    --record: #ff1744;
    --warning: #ff9800;
  }
  
  body {
    background: linear-gradient(135deg, var(--darker), #1a1a2e);
    color: var(--light);
    line-height: 1.6;
    padding: 20px;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }
  
  .container {
    max-width: 1800px;
    margin: 0 auto;
    width: 100%;
  }
  
  header {
    text-align: center;
    padding: 20px;
    margin-bottom: 30px;
    background: rgba(30, 30, 46, 0.7);
    border-radius: 15px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(92, 119, 179, 0.3);
  }
  
  h1 {
    font-size: 2.8rem;
    margin-bottom: 10px;
    color: var(--primary);
    text-shadow: 0 0 15px rgba(41, 98, 255, 0.5);
    background: linear-gradient(90deg, var(--primary), var(--secondary));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }
  
  .subtitle {
    font-size: 1.3rem;
    color: #bb86fc;
    max-width: 800px;
    margin: 0 auto 20px;
  }
  
  .protocol-tags {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin: 20px 0;
    flex-wrap: wrap;
  }
  
  .protocol-tag {
    background: rgba(19, 38, 74, 0.7);
    padding: 8px 20px;
    border-radius: 30px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 8px;
    border: 1px solid rgba(92, 119, 179, 0.5);
  }
  
  .main-content {
    display: grid;
    grid-template-columns: 1fr 350px;
    gap: 25px;
    margin-bottom: 30px;
  }
  
  .panel {
    background: rgba(30, 30, 46, 0.7);
    border-radius: 15px;
    padding: 25px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(92, 119, 179, 0.3);
  }
  
  .panel-title {
    font-size: 1.6rem;
    margin-bottom: 25px;
    color: var(--primary);
    display: flex;
    align-items: center;
    gap: 15px;
    padding-bottom: 15px;
    border-bottom: 2px solid rgba(92, 119, 179, 0.3);
  }
  
  .camera-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 20px;
    margin-top: 15px;
  }
  
  .camera-container {
    position: relative;
    background: #0d1b2a;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    height: 300px;
  }
  
  .camera-container:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 25px rgba(79, 195, 247, 0.3);
  }
  
  .camera-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 15px;
    background: rgba(19, 38, 74, 0.8);
    border-bottom: 1px solid rgba(92, 119, 179, 0.3);
  }
  
  .camera-id {
    font-weight: bold;
    color: #bb86fc;
    font-size: 1.1rem;
  }
  
  .camera-controls {
    display: flex;
    gap: 5px;
  }
  
  .canvas-container {
    position: relative;
    height: calc(100% - 50px);
    background: #000;
  }
  
  .canvas {
    width: 100%;
    height: 100%;
    display: block;
    image-rendering: pixelated;
  }
  
  .recording-indicator {
    position: absolute;
    top: 10px;
    right: 10px;
    background: var(--record);
    color: white;
    padding: 3px 8px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    display: none;
    animation: pulse 1s infinite;
    z-index: 100;
  }
  
  @keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
  }
  
  .speed-display {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 3px 8px;
    border-radius: 4px;
    font-size: 12px;
    z-index: 100;
  }
  
  .controls-row {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    justify-content: center;
    margin-top: 25px;
  }
  
  .control-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: center;
    background: rgba(19, 38, 74, 0.5);
    padding: 15px;
    border-radius: 10px;
    min-width: 200px;
  }
  
  .url-input {
    display: flex;
    gap: 10px;
    width: 100%;
    margin-bottom: 15px;
  }
  
  .url-input input {
    flex: 1;
    padding: 10px 15px;
    background: rgba(10, 25, 47, 0.8);
    border: 1px solid rgba(92, 119, 179, 0.5);
    border-radius: 8px;
    color: #e0e0e0;
    font-size: 1rem;
  }
  
  .btn {
    padding: 10px 20px;
    background: linear-gradient(135deg, var(--primary), #304ffe);
    border: none;
    border-radius: 8px;
    color: white;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    display: inline-flex;
    align-items: center;
    gap: 8px;
  }
  
  .btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(41, 98, 255, 0.4);
  }
  
  .btn-secondary {
    background: rgba(41, 98, 255, 0.2);
    border: 1px solid rgba(92, 119, 179, 0.5);
  }
  
  .btn-danger {
    background: linear-gradient(135deg, var(--danger), #d32f2f);
  }
  
  .btn-record {
    background: linear-gradient(135deg, var(--record), #d50000);
  }
  
  .btn-warning {
    background: linear-gradient(135deg, var(--warning), #f57c00);
  }
  
  input[type="range"] {
    width: 100%;
    height: 8px;
    background: rgba(92, 119, 179, 0.3);
    border-radius: 4px;
    outline: none;
  }
  
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 20px;
    height: 20px;
    background: #4fc3f7;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 8px rgba(79, 195, 247, 0.8);
  }
  
  .calibration {
    background: #333;
    padding: 15px;
    border-radius: 8px;
    margin: 10px 0;
  }
  
  .calibration-grid {
    position: relative;
    height: 200px;
    background: #222;
    border: 1px solid #444;
    margin-top: 10px;
    border-radius: 4px;
  }
  
  .calibration-point {
    position: absolute;
    width: 12px;
    height: 12px;
    background: #f44336;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    cursor: move;
    box-shadow: 0 0 8px rgba(244, 67, 54, 0.7);
  }
  
  .log-container {
    height: 100%;
    display: flex;
    flex-direction: column;
  }
  
  #log {
    flex: 1;
    background: rgba(10, 20, 40, 0.8);
    border-radius: 12px;
    padding: 15px;
    overflow-y: auto;
    font-family: monospace;
    border: 1px solid rgba(92, 119, 179, 0.3);
    max-height: 400px;
  }
  
  .log-entry {
    margin-bottom: 15px;
    padding-bottom: 15px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }
  
  .log-timestamp {
    color: var(--secondary);
    font-weight: 600;
    margin-bottom: 5px;
  }
  
  .log-message {
    color: var(--light);
    line-height: 1.5;
  }
  
  .protocol-info {
    margin-top: 30px;
    padding: 25px;
    background: rgba(19, 38, 74, 0.5);
    border-radius: 15px;
  }
  
  .protocol-info h2 {
    font-size: 1.8rem;
    margin-bottom: 20px;
    color: var(--primary);
    display: flex;
    align-items: center;
    gap: 12px;
  }
  
  .protocol-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 25px;
    margin-top: 20px;
  }
  
  .protocol-card {
    background: rgba(10, 20, 40, 0.8);
    padding: 20px;
    border-radius: 12px;
    border: 1px solid rgba(92, 119, 179, 0.3);
  }
  
  .protocol-card h3 {
    font-size: 1.4rem;
    margin-bottom: 15px;
    color: var(--secondary);
    display: flex;
    align-items: center;
    gap: 12px;
  }
  
  .protocol-card p {
    margin-bottom: 15px;
    line-height: 1.7;
  }
  
  .protocol-card .example {
    background: rgba(0, 0, 0, 0.3);
    padding: 10px;
    border-radius: 6px;
    font-family: monospace;
    font-size: 0.95rem;
    margin: 15px 0;
  }
  
  .recordings-panel {
    margin-top: 30px;
  }
  
  .recordings-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
    margin-top: 20px;
  }
  
  .recording-card {
    background: rgba(10, 20, 40, 0.8);
    padding: 20px;
    border-radius: 12px;
    border: 1px solid rgba(92, 119, 179, 0.3);
    display: flex;
    flex-direction: column;
  }
  
  .recording-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
  }
  
  .recording-thumbnail {
    width: 100%;
    height: 150px;
    background: #1a1a2e;
    border-radius: 8px;
    overflow: hidden;
    position: relative;
    margin-bottom: 15px;
  }
  
  .recording-thumbnail img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  
  .recording-info {
    margin-top: auto;
  }
  
  .recording-meta {
    display: flex;
    justify-content: space-between;
    margin-top: 10px;
    font-size: 0.9rem;
    color: #bb86fc;
  }
  
  .download-btn {
    background: var(--primary);
    color: white;
    border: none;
    border-radius: 6px;
    padding: 8px 15px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    margin-top: 15px;
  }
  
  .download-btn:hover {
    background: #1e40af;
  }
  
  .validation-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
  }
  
  .validation-modal.active {
    opacity: 1;
    visibility: visible;
  }
  
  .validation-content {
    background: rgba(30, 30, 46, 0.95);
    border-radius: 15px;
    padding: 30px;
    width: 90%;
    max-width: 600px;
    box-shadow: 0 15px 50px rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(92, 119, 179, 0.5);
  }
  
  .validation-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
  }
  
  .validation-header h2 {
    color: var(--primary);
    font-size: 1.8rem;
  }
  
  .close-btn {
    background: none;
    border: none;
    color: #fff;
    font-size: 1.5rem;
    cursor: pointer;
  }
  
  .validation-body {
    margin-bottom: 20px;
  }
  
  .validation-preview {
    width: 100%;
    height: 250px;
    background: #000;
    border-radius: 8px;
    overflow: hidden;
    margin-bottom: 20px;
  }
  
  .validation-preview video {
    width: 100%;
    height: 100%;
    object-fit: contain;
  }
  
  .validation-stats {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 15px;
  }
  
  .stat-card {
    background: rgba(19, 38, 74, 0.5);
    padding: 15px;
    border-radius: 8px;
  }
  
  .stat-card h3 {
    font-size: 1rem;
    color: #bb86fc;
    margin-bottom: 5px;
  }
  
  .stat-value {
    font-size: 1.2rem;
    font-weight: bold;
  }
  
  .validation-actions {
    display: flex;
    gap: 15px;
    justify-content: flex-end;
  }
  
  .progress-container {
    height: 8px;
    background: rgba(92, 119, 179, 0.3);
    border-radius: 4px;
    margin-bottom: 15px;
    overflow: hidden;
  }
  
  .progress-bar {
    height: 100%;
    background: var(--secondary);
    width: 0%;
    transition: width 0.3s ease;
  }
  
  .validation-status {
    text-align: center;
    margin: 15px 0;
    min-height: 24px;
  }
  
  @media (max-width: 1200px) {
    .main-content {
      grid-template-columns: 1fr;
    }
    
    .camera-grid {
      grid-template-columns: 1fr;
    }
  }

  /* Footer styles for contact info */
  footer {
    text-align: center;
    padding: 20px;
    margin-top: 30px;
    background: rgba(30, 30, 46, 0.7);
    border-radius: 15px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(92, 119, 179, 0.3);
    color: #bb86fc;
    font-size: 1rem;
  }

  footer p {
    margin-bottom: 8px;
  }

  footer a {
    color: var(--primary);
    text-decoration: none;
    font-weight: 600;
  }

  footer a:hover {
    text-decoration: underline;
  }

  /* Login Modal Styles */
  .login-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
    transition: opacity 0.3s ease, visibility 0.3s ease;
  }

  .login-modal.hidden {
    opacity: 0;
    visibility: hidden;
  }

  .login-content {
    background: rgba(30, 30, 46, 0.95);
    border-radius: 15px;
    padding: 40px;
    width: 90%;
    max-width: 450px;
    box-shadow: 0 15px 50px rgba(0, 0, 0, 0.7);
    border: 1px solid rgba(92, 119, 179, 0.5);
    text-align: center;
  }

  .login-content h2 {
    color: var(--primary);
    font-size: 2.2rem;
    margin-bottom: 30px;
  }

  .login-form-group {
    margin-bottom: 20px;
    text-align: left;
  }

  .login-form-group label {
    display: block;
    margin-bottom: 8px;
    color: var(--light);
    font-weight: 600;
  }

  .login-form-group input {
    width: 100%;
    padding: 12px 15px;
    background: rgba(10, 25, 47, 0.8);
    border: 1px solid rgba(92, 119, 179, 0.5);
    border-radius: 8px;
    color: #e0e0e0;
    font-size: 1rem;
  }

  .login-error {
    color: var(--danger);
    margin-top: 15px;
    font-weight: 600;
    min-height: 20px; /* Reserve space */
  }

  .login-button {
    width: 100%;
    padding: 12px 25px;
    font-size: 1.1rem;
    margin-top: 20px;
  }

  .logout-button {
    position: absolute;
    top: 20px;
    right: 20px;
    padding: 10px 15px;
    background: var(--danger);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    transition: background 0.3s ease;
    z-index: 100;
  }

  .logout-button:hover {
    background: #d32f2f;
  }

</style>
</head>
<body>
<div class="login-modal" id="loginModal">
  <div class="login-content">
    <h2><i class="fas fa-lock"></i> Login to Speed Detection</h2>
    <div class="login-form-group">
      <label for="username">Username:</label>
      <input type="text" id="username" placeholder="Enter your username">
    </div>
    <div class="login-form-group">
      <label for="password">Password:</label>
      <input type="password" id="password" placeholder="Enter your password">
    </div>
    <div class="login-error" id="loginError"></div>
    <button class="btn login-button" id="loginBtn">
      <i class="fas fa-sign-in-alt"></i> Login
    </button>
  </div>
</div>

<button class="logout-button hidden" id="logoutBtn">
  <i class="fas fa-sign-out-alt"></i> Logout
</button>

<div class="container hidden" id="mainAppContent">
  <header>
    <h1><i class="fas fa-car-burst"></i> Universal Multi-Stream Speed Detection</h1>
    <p class="subtitle">Innovated by innovator Amer Abdullah Real-time vehicle speed detection from multiple cameras with violation recording</p>
    <p class="subtitle">
      Contact: <a href="tel:+251913395143">+251913395143</a> | 
      Email: <a href="mailto:amerabdulah634@gmail.com">amerabdulah634@gmail.com</a>
    </p>
    
    <div class="protocol-tags">
      <div class="protocol-tag"><i class="fas fa-satellite-dish"></i> RTSP</div>
      <div class="protocol-tag"><i class="fas fa-bolt"></i> RTMP</div>
      <div class="protocol-tag"><i class="fas fa-wave-square"></i> HLS</div>
      <div class="protocol-tag"><i class="fas fa-image"></i> MJPEG</div>
      <div class="protocol-tag"><i class="fas fa-wifi"></i> WebRTC</div>
    </div>
  </header>
  
  <div class="main-content">
    <div class="panel">
      <div class="panel-title">
        <i class="fas fa-video"></i> Camera Streams
      </div>
      
      <div class="camera-grid" id="cameraGrid">
        <!-- Camera containers will be added here dynamically -->
      </div>
      
      <div class="controls-row">
        <div class="control-group">
          <h3>Add New Camera</h3>
          <div class="url-input">
            <input type="text" id="newCamUrl" placeholder="Enter camera stream URL">
          </div>
          <button class="btn" id="addCameraBtn">
            <i class="fas fa-plus"></i> Add Camera
          </button>
        </div>
        
        <div class="control-group">
          <h3>Speed Control</h3>
          <div>
            <label>Speed Limit: <span id="speedVal">60</span> km/h</label>
            <input type="range" id="speedThreshold" min="1" max="120" value="60">
          </div>
        </div>
        
        <div class="control-group">
          <h3>Processing Rate</h3>
          <select id="fpsControl">
            <option value="100">10 FPS (Low CPU)</option>
            <option value="66">15 FPS (Balanced)</option>
            <option value="50">20 FPS (High Accuracy)</option>
          </select>
        </div>
      </div>
    </div>
    
    <div class="panel log-container">
      <div class="panel-title">
        <i class="fas fa-clipboard-list"></i> Detection Log
      </div>
      
      <div id="log">
        <div class="log-entry">
          <div class="log-timestamp">[System Startup]</div>
          <div class="log-message">Multi-Stream Speed Detection System initialized. Add cameras to begin.</div>
        </div>
        <div class="log-entry">
          <div class="log-timestamp">[System Info]</div>
          <div class="log-message">Violation videos will be validated before download.</div>
        </div>
      </div>
      
      <div class="controls-row" style="margin-top: 20px;">
        <button class="btn btn-secondary" id="clearLogBtn">
          <i class="fas fa-trash"></i> Clear Log
        </button>
        <button class="btn btn-danger" id="resetBtn">
          <i class="fas fa-sync-alt"></i> Reset All
        </button>
      </div>
    </div>
  </div>
  
  <div class="panel">
    <div class="panel-title">
      <i class="fas fa-ruler"></i> Calibration
    </div>
    
    <div class="calibration">
      <p>Set two points on the image with a known distance between them</p>
      
      <div class="calibration-grid" id="calibrationGrid">
        <!-- Calibration points will be added here -->
      </div>
      
      <div style="margin-top: 20px; display: flex; gap: 15px; align-items: center;">
        <div>
          <label>Reference Distance (meters): </label>
          <input type="number" id="refDistance" min="1" value="10" step="0.1" 
                 style="padding: 10px; width: 120px; background: rgba(10,20,40,0.8); border: 1px solid rgba(92,119,179,0.5); border-radius: 8px; color: white;"/>
        </div>
        <button class="btn" id="calcCalibration">
          <i class="fas fa-calculator"></i> Calculate
        </button>
        <div style="font-size: 1.1rem;">
          Pixel-to-Meter: <span id="calibrationResult">0.0333</span>
        </div>
      </div>
    </div>
  </div>
  
  <div class="panel recordings-panel">
    <div class="panel-title">
      <i class="fas fa-file-video"></i> Recorded Violations
    </div>
    
    <div id="recordingsContainer">
      <div class="recordings-list" id="recordingsList">
        <!-- Recordings will be added here dynamically -->
      </div>
    </div>
  </div>

  <footer>
    <p>For inquiries, please contact:</p>
    <p><strong>Amer Abdullah</strong></p>
    <p><strong>Raji Technology</strong></p>
    <p>Phone: <a href="tel:+251913395143">+251913395143</a></p>
    <p>Email: <a href="mailto:amerabdulah634@gmail.com">amerabdulah634@gmail.com</a></p>
  </footer>
</div>

<!-- Validation Modal -->
<div class="validation-modal" id="validationModal">
  <div class="validation-content">
    <div class="validation-header">
      <h2><i class="fas fa-video"></i> Video Validation</h2>
      <button class="close-btn" id="closeValidation">&times;</button>
    </div>
    <div class="validation-body">
      <div class="validation-preview">
        <video id="validationVideo" controls></video>
      </div>
      <div class="progress-container">
        <div class="progress-bar" id="validationProgress"></div>
      </div>
      <div class="validation-status" id="validationStatus">Validating video integrity...</div>
      <div class="validation-stats">
        <div class="stat-card">
          <h3>Video Status</h3>
          <div class="stat-value" id="videoStatus">Checking...</div>
        </div>
        <div class="stat-card">
          <h3>Audio Status</h3>
          <div class="stat-value" id="audioStatus">Checking...</div>
        </div>
        <div class="stat-card">
          <h3>Duration</h3>
          <div class="stat-value" id="durationStat">0s</div>
        </div>
        <div class="stat-card">
          <h3>File Size</h3>
          <div class="stat-value" id="sizeStat">0 MB</div>
        </div>
      </div>
    </div>
    <div class="validation-actions">
      <button class="btn btn-secondary" id="cancelDownload">
        <i class="fas fa-times"></i> Cancel
      </button>
      <button class="btn" id="confirmDownload">
        <i class="fas fa-download"></i> Download Anyway
      </button>
      <button class="btn" id="downloadValidated" style="display: none;">
        <i class="fas fa-download"></i> Download Validated
      </button>
    </div>
  </div>
</div>

<!-- TensorFlow.js and COCO-SSD -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.13.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

<!-- HLS.js for HLS stream support -->
<script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.10/dist/hls.min.js"></script>

<script>
  // Constants
  const MAX_CAMERAS = 4;
  
  // DOM Elements
  const newCamUrl = document.getElementById("newCamUrl");
  const cameraGrid = document.getElementById("cameraGrid");
  const addCameraBtn = document.getElementById("addCameraBtn");
  const speedThresholdInput = document.getElementById("speedThreshold");
  const speedValSpan = document.getElementById("speedVal");
  const logDiv = document.getElementById("log");
  const clearLogBtn = document.getElementById("clearLogBtn");
  const resetBtn = document.getElementById("resetBtn");
  const fpsControl = document.getElementById("fpsControl");
  const calibrationGrid = document.getElementById("calibrationGrid");
  const refDistanceInput = document.getElementById("refDistance");
  const calcCalibrationBtn = document.getElementById("calcCalibration");
  const calibrationResult = document.getElementById("calibrationResult");
  const recordingsList = document.getElementById("recordingsList");
  const validationModal = document.getElementById("validationModal");
  const validationVideo = document.getElementById("validationVideo");
  const validationProgress = document.getElementById("validationProgress");
  const validationStatus = document.getElementById("validationStatus");
  const videoStatus = document.getElementById("videoStatus");
  const audioStatus = document.getElementById("audioStatus");
  const durationStat = document.getElementById("durationStat");
  const sizeStat = document.getElementById("sizeStat");
  const closeValidation = document.getElementById("closeValidation");
  const cancelDownload = document.getElementById("cancelDownload");
  const confirmDownload = document.getElementById("confirmDownload");
  const downloadValidated = document.getElementById("downloadValidated");

  // Login related DOM elements
  const loginModal = document.getElementById("loginModal");
  const usernameInput = document.getElementById("username");
  const passwordInput = document.getElementById("password");
  const loginBtn = document.getElementById("loginBtn");
  const loginError = document.getElementById("loginError");
  const mainAppContent = document.getElementById("mainAppContent");
  const logoutBtn = document.getElementById("logoutBtn");

  // Configuration
  let pixelToMeter = 0.0333;
  let speedThreshold = parseInt(speedThresholdInput.value);
  speedValSpan.textContent = speedThreshold;
  let frameInterval = parseInt(fpsControl.value);
  let calibrationPoints = [];
  let lineElement = null;

  // Tracking
  let model = null;
  let allCameras = [];
  let violationCount = 0;
  let recordings = [];
  let currentValidation = null;
  
  // Alert sound
  const alertSound = new Audio("https://assets.mixkit.co/sfx/preview/mixkit-alert-alarm-1005.mp3");
  
  // --- Authentication Logic ---
  const CORRECT_USERNAME = "user"; // Hardcoded username for demo
  const CORRECT_PASSWORD = "password"; // Hardcoded password for demo

  function showLogin() {
    loginModal.classList.remove("hidden");
    mainAppContent.classList.add("hidden");
    logoutBtn.classList.add("hidden");
    usernameInput.value = "";
    passwordInput.value = "";
    loginError.textContent = "";
  }

  function hideLogin() {
    loginModal.classList.add("hidden");
    mainAppContent.classList.remove("hidden");
    logoutBtn.classList.remove("hidden");
  }

  loginBtn.addEventListener("click", () => {
    const username = usernameInput.value;
    const password = passwordInput.value;

    if (username === CORRECT_USERNAME && password === CORRECT_PASSWORD) {
      hideLogin();
      addLogEntry("User logged in successfully.");
    } else {
      loginError.textContent = "Invalid username or password.";
    }
  });

  logoutBtn.addEventListener("click", () => {
    showLogin();
    addLogEntry("User logged out.");
    // Stop all active camera streams on logout
    allCameras.forEach(cam => cam.stopStream());
  });

  // Initialize: show login screen on page load
  document.addEventListener("DOMContentLoaded", showLogin);

  // --- End Authentication Logic ---

  // Recording functions
  function saveViolationRecording(cameraId, vehicleId, speedKmH, blob) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `violation_cam${cameraId+1}_${vehicleId}_${speedKmH.toFixed(0)}kmh_${timestamp}.webm`;
    
    // Create a thumbnail for demo purposes
    const thumbnailUrl = 'https://images.unsplash.com/photo-1605559424843-9e4c228bf1c2?auto=format&fit=crop&q=80&w=400';
    
    // Create recording object
    const recording = {
      id: Date.now(),
      cameraId: cameraId+1,
      vehicleId,
      speedKmH,
      timestamp: new Date(),
      filename,
      blob: blob,
      thumbnailUrl
    };
    
    // Add to recordings array
    recordings.push(recording);
    
    // Add to UI
    addRecordingToUI(recording);
    
    // Add log entry
    addLogEntry(`Saved violation video: ${filename}`);
  }
  
  function addRecordingToUI(recording) {
    const dateStr = recording.timestamp.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric'
    });
    
    const timeStr = recording.timestamp.toLocaleTimeString('en-US', {
      hour: '2-digit',
      minute: '2-digit'
    });
    
    const recordingCard = document.createElement('div');
    recordingCard.className = 'recording-card';
    recordingCard.innerHTML = `
      <div class="recording-header">
        <h3>Violation #${recordings.length}</h3>
        <span class="recording-date">${dateStr}, ${timeStr}</span>
      </div>
      <div class="recording-thumbnail">
        <img src="${recording.thumbnailUrl}" alt="Violation thumbnail">
      </div>
      <div class="recording-info">
        <p>Vehicle exceeded speed limit: <strong>${recording.speedKmH.toFixed(1)} km/h</strong></p>
        <div class="recording-meta">
          <span>Camera ${recording.cameraId}</span>
          <span>Duration: 5s</span>
        </div>
        <button class="download-btn" data-id="${recording.id}">
          <i class="fas fa-download"></i> Download Video
        </button>
      </div>
    `;
    
    recordingsList.prepend(recordingCard);
    
    // Add download event listener
    recordingCard.querySelector('.download-btn').addEventListener('click', function() {
      validateAndDownload(recording);
    });
  }
  
  // Validate video before downloading
  function validateAndDownload(recording) {
    currentValidation = recording;
    validationModal.classList.add('active');
    
    // Create URL from blob for preview
    const videoUrl = URL.createObjectURL(recording.blob);
    validationVideo.src = videoUrl;
    
    // Reset validation UI
    validationProgress.style.width = '0%';
    validationStatus.textContent = 'Validating video integrity...';
    videoStatus.textContent = 'Checking...';
    audioStatus.textContent = 'Checking...';
    durationStat.textContent = '0s';
    sizeStat.textContent = '0 MB';
    downloadValidated.style.display = 'none';
    
    addLogEntry(`Validating video: ${recording.filename}`);
    
    // Play the video for preview
    validationVideo.play().catch(e => {
      console.log("Video play failed:", e);
      addLogEntry(`Video validation error: ${e.message}`);
    });
    
    // Simulate validation process
    let progress = 0;
    const interval = setInterval(() => {
      progress += Math.random() * 10;
      if (progress > 100) progress = 100;
      validationProgress.style.width = `${progress}%`;
      
      // Update status at different progress points
      if (progress > 20) {
        videoStatus.textContent = '✅ Valid';
        validationStatus.textContent = 'Video stream validated successfully';
      }
      if (progress > 40) {
        audioStatus.textContent = '✅ Valid';
        validationStatus.textContent = 'Audio stream validated successfully';
      }
      if (progress > 60) {
        durationStat.textContent = '5.2s';
        validationStatus.textContent = 'Duration validated';
      }
      if (progress > 80) {
        const sizeMB = (recording.blob.size / (1024 * 1024)).toFixed(2);
        sizeStat.textContent = `${sizeMB} MB`;
        validationStatus.textContent = 'File size validated';
      }
      if (progress === 100) {
        clearInterval(interval);
        validationStatus.textContent = '✅ Validation successful! Video is ready for download';
        downloadValidated.style.display = 'inline-flex';
        confirmDownload.style.display = 'none';
      }
    }, 200);
  }
  
  function downloadRecording(recording) {
    addLogEntry(`Downloading recording: ${recording.filename}`);
    
    // Create a temporary link to trigger download
    const link = document.createElement('a');
    const url = URL.createObjectURL(recording.blob);
    link.href = url;
    link.download = recording.filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Revoke the URL after some time
    setTimeout(() => {
      URL.revokeObjectURL(url);
    }, 1000);
    
    // Close modal after download
    validationModal.classList.remove('active');
  }

  // Add log entry
  function addLogEntry(message) {
    const now = new Date();
    const timeStr = `[${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}]`;
    
    const logEntry = document.createElement("div");
    logEntry.className = "log-entry";
    logEntry.innerHTML = `
      <div class="log-timestamp">${timeStr}</div>
      <div class="log-message">${message}</div>
    `;
    
    logDiv.prepend(logEntry);
    
    // Limit to 20 entries
    if (logDiv.children.length > 20) {
      logDiv.removeChild(logDiv.lastChild);
    }
  }

  // Camera class to manage each stream
  class Camera {
    constructor(id, url) {
      this.id = id;
      this.url = url;
      this.streaming = false;
      this.intervalId = null;
      this.trackedObjects = [];
      this.nextId = 0;
      this.minHistoryFrames = 3;
      this.maxLostFrames = 5;
      this.active = false;
      this.maxSpeed = 0;
      this.recording = false;
      this.mediaRecorder = null;
      this.recordedChunks = [];
      this.currentViolation = null;
      
      // Create camera container
      this.container = document.createElement('div');
      this.container.className = 'camera-container';
      this.container.id = `camera-${id}`;
      
      // Create camera header
      const header = document.createElement('div');
      header.className = 'camera-header';
      
      const cameraId = document.createElement('div');
      cameraId.className = 'camera-id';
      cameraId.textContent = `Camera ${id + 1}`;
      
      this.statusIndicator = document.createElement('div');
      this.statusIndicator.className = 'status-indicator';
      this.statusIndicator.style.background = '#f44336';
      this.statusIndicator.style.width = '12px';
      this.statusIndicator.style.height = '12px';
      this.statusIndicator.style.borderRadius = '50%';
      this.statusIndicator.style.display = 'inline-block';
      this.statusIndicator.style.marginLeft = '8px';
      
      const controls = document.createElement('div');
      controls.className = 'camera-controls';
      
      this.toggleBtn = document.createElement('button');
      this.toggleBtn.className = 'btn';
      this.toggleBtn.style.padding = '5px 10px';
      this.toggleBtn.style.fontSize = '0.9rem';
      this.toggleBtn.textContent = 'Start';
      this.toggleBtn.addEventListener('click', () => this.toggleStream());
      
      const removeBtn = document.createElement('button');
      removeBtn.className = 'btn btn-danger';
      removeBtn.style.padding = '5px 10px';
      removeBtn.style.fontSize = '0.9rem';
      removeBtn.textContent = 'Remove';
      removeBtn.addEventListener('click', () => this.remove());
      
      controls.appendChild(this.toggleBtn);
      controls.appendChild(removeBtn);
      
      header.appendChild(cameraId);
      header.appendChild(this.statusIndicator);
      header.appendChild(controls);
      
      // Create canvas container
      const canvasContainer = document.createElement('div');
      canvasContainer.className = 'canvas-container';
      
      this.canvas = document.createElement('canvas');
      this.canvas.className = 'canvas';
      this.canvas.width = 640;
      this.canvas.height = 480;
      this.ctx = this.canvas.getContext('2d');
      this.ctx.fillStyle = '#000';
      this.ctx.fillRect(0, 0, 640, 480);
      
      this.recordingIndicator = document.createElement('div');
      this.recordingIndicator.className = 'recording-indicator';
      this.recordingIndicator.textContent = 'REC';
      
      this.speedDisplay = document.createElement('div');
      this.speedDisplay.className = 'speed-display';
      this.speedDisplay.textContent = '0 km/h';
      
      canvasContainer.appendChild(this.canvas);
      canvasContainer.appendChild(this.recordingIndicator);
      canvasContainer.appendChild(this.speedDisplay);
      
      this.container.appendChild(header);
      this.container.appendChild(canvasContainer);
      
      cameraGrid.appendChild(this.container);
      
      // Create image element
      this.img = new Image();
      this.img.crossOrigin = "anonymous";
      
      addLogEntry(`Camera ${id+1} added: ${url}`);
    }
    
    async toggleStream() {
      if (!this.streaming) {
        await this.startStream();
      } else {
        this.stopStream();
      }
    }
    
    async startStream() {
      if (!this.url) {
        // Using a custom message box instead of alert()
        showCustomMessageBox("Please enter a valid stream URL.");
        return;
      }

      this.toggleBtn.disabled = true;
      this.toggleBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Starting';
      addLogEntry(`Starting Camera ${this.id + 1}...`);
      
      try {
        if (!model) {
          addLogEntry("Loading object detection model...");
          model = await cocoSsd.load();
          addLogEntry("Model loaded successfully");
        }
        
        // Determine stream type
        if (this.url.includes('.m3u8')) {
          this.streamType = 'hls';
          addLogEntry(`Camera ${this.id+1}: Initializing HLS stream...`);
          
          // Setup HLS
          if (Hls.isSupported()) {
            this.hls = new Hls();
            this.hls.loadSource(this.url);
            
            // Create video element
            this.video = document.createElement('video');
            this.video.style.display = 'none';
            this.video.playsInline = true;
            document.body.appendChild(this.video);
            
            this.hls.attachMedia(this.video);
            
            this.hls.on(Hls.Events.MANIFEST_PARSED, () => {
              addLogEntry(`Camera ${this.id+1}: HLS stream loaded`);
              this.video.play().then(() => {
                this.startProcessing();
              }).catch(e => {
                addLogEntry(`Camera ${this.id+1}: Error playing video - ${e.message}`);
                this.toggleBtn.disabled = false;
                this.toggleBtn.textContent = 'Start';
              });
            });
            
            this.hls.on(Hls.Events.ERROR, (event, data) => {
              if (data.fatal) {
                addLogEntry(`Camera ${this.id+1}: HLS Error - ${data.details}`);
                this.toggleBtn.disabled = false;
                this.toggleBtn.textContent = 'Start';
              }
            });
          } else {
            addLogEntry(`Camera ${this.id+1}: HLS is not supported by your browser.`);
            this.toggleBtn.disabled = false;
            this.toggleBtn.textContent = 'Start';
          }
        } else if (this.url.startsWith('http') && (this.url.includes('.jpg') || this.url.includes('.jpeg') || this.url.includes('.png'))) {
            this.streamType = 'mjpeg'; // Simplified MJPEG-like handling for static images
            addLogEntry(`Camera ${this.id+1}: Initializing MJPEG-like stream...`);
            this.img.onload = () => {
                this.startProcessing();
            };
            this.img.onerror = (e) => {
                addLogEntry(`Camera ${this.id+1}: Error loading image stream - ${e.message || 'Check URL or CORS'}`);
                this.toggleBtn.disabled = false;
                this.toggleBtn.textContent = 'Start';
            };
            this.img.src = this.url; // Load the initial image
        }
        else {
          addLogEntry(`Camera ${this.id+1}: Unsupported stream type or URL. Only HLS and basic image URLs are supported in this demo.`);
          this.toggleBtn.disabled = false;
          this.toggleBtn.textContent = 'Start';
          return;
        }

        this.streaming = true;
        this.toggleBtn.textContent = 'Stop';
        this.statusIndicator.style.background = '#00c853'; // Green for active
        this.toggleBtn.disabled = false;
        addLogEntry(`Camera ${this.id+1} stream started.`);

      } catch (error) {
        addLogEntry(`Error starting Camera ${this.id + 1}: ${error.message}`);
        this.toggleBtn.disabled = false;
        this.toggleBtn.textContent = 'Start';
        this.statusIndicator.style.background = '#f44336'; // Red for error
      }
    }
    
    stopStream() {
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
      if (this.hls) {
        this.hls.destroy();
        this.hls = null;
      }
      if (this.video && this.video.parentNode) {
        this.video.pause();
        this.video.parentNode.removeChild(this.video);
        this.video = null;
      }
      this.streaming = false;
      this.active = false;
      this.toggleBtn.textContent = 'Start';
      this.statusIndicator.style.background = '#f44336'; // Red for stopped
      this.ctx.fillStyle = '#000';
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      this.speedDisplay.textContent = '0 km/h';
      this.recordingIndicator.style.display = 'none';
      this.trackedObjects = [];
      addLogEntry(`Camera ${this.id+1} stream stopped.`);
    }
    
    startProcessing() {
        this.active = true;
        this.intervalId = setInterval(() => this.processFrame(), frameInterval);
    }

    async processFrame() {
        if (!this.active || !model) return;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.drawImage(this.streamType === 'hls' ? this.video : this.img, 0, 0, this.canvas.width, this.canvas.height);

        const predictions = await model.detect(this.canvas);
        this.updateTracking(predictions);
        this.drawDetections();
    }
    
    updateTracking(predictions) {
      const currentTime = Date.now();
      const newTrackedObjects = [];

      predictions.forEach(prediction => {
        if (prediction.class === 'car' || prediction.class === 'truck' || prediction.class === 'bus') {
          const [x, y, width, height] = prediction.bbox;
          const centerX = x + width / 2;
          const centerY = y + height / 2;

          let matched = false;
          for (let i = 0; i < this.trackedObjects.length; i++) {
            const tracked = this.trackedObjects[i];
            // Simple distance-based matching
            const distance = Math.sqrt(Math.pow(centerX - tracked.lastX, 2) + Math.pow(centerY - tracked.lastY, 2));

            if (distance < 100) { // Threshold for matching
              // Update existing tracked object
              tracked.history.push({ x: centerX, y: centerY, timestamp: currentTime });
              tracked.lastX = centerX;
              tracked.lastY = centerY;
              tracked.lostFrames = 0;
              matched = true;

              // Calculate speed if enough history
              if (tracked.history.length > this.minHistoryFrames) {
                const firstPoint = tracked.history[0];
                const lastPoint = tracked.history[tracked.history.length - 1];

                const pixelDistance = Math.sqrt(Math.pow(lastPoint.x - firstPoint.x, 2) + Math.pow(lastPoint.y - firstPoint.y, 2));
                const timeDiffSeconds = (lastPoint.timestamp - firstPoint.timestamp) / 1000;

                if (timeDiffSeconds > 0) {
                  const meterDistance = pixelDistance * pixelToMeter;
                  const speedMps = meterDistance / timeDiffSeconds;
                  const speedKmH = speedMps * 3.6; // Convert m/s to km/h
                  tracked.currentSpeed = speedKmH;
                  if (speedKmH > this.maxSpeed) {
                    this.maxSpeed = speedKmH;
                  }

                  // Check for violation
                  if (speedKmH > speedThreshold && !tracked.violationRecorded) {
                    addLogEntry(`Camera ${this.id+1}: VIOLATION! Vehicle (ID: ${tracked.id}) detected at ${speedKmH.toFixed(1)} km/h (Limit: ${speedThreshold} km/h)`);
                    alertSound.play();
                    tracked.violationRecorded = true;
                    this.startRecordingViolation(tracked.id, speedKmH);
                  }
                }
              }
              newTrackedObjects.push(tracked);
              break;
            }
          }

          if (!matched) {
            // Add new tracked object
            newTrackedObjects.push({
              id: this.nextId++,
              class: prediction.class,
              lastX: centerX,
              lastY: centerY,
              history: [{ x: centerX, y: centerY, timestamp: currentTime }],
              lostFrames: 0,
              currentSpeed: 0,
              violationRecorded: false
            });
          }
        }
      });

      // Increment lost frames for unmatched objects and remove if lost too long
      this.trackedObjects.forEach(tracked => {
        if (!newTrackedObjects.includes(tracked)) {
          tracked.lostFrames++;
          if (tracked.lostFrames < this.maxLostFrames) {
            newTrackedObjects.push(tracked); // Keep for a few more frames
          }
        }
      });

      this.trackedObjects = newTrackedObjects;
      this.speedDisplay.textContent = `${this.maxSpeed.toFixed(0)} km/h`;
    }
    
    drawDetections() {
      this.trackedObjects.forEach(obj => {
        const [x, y, width, height] = obj.bbox; // Assuming bbox is available or can be derived
        // For simplicity, let's use the last known center and a fixed size for drawing
        const drawX = obj.lastX - 30; // Approx half width
        const drawY = obj.lastY - 30; // Approx half height
        const drawWidth = 60;
        const drawHeight = 60;

        this.ctx.beginPath();
        this.ctx.rect(drawX, drawY, drawWidth, drawHeight);
        this.ctx.lineWidth = 2;
        this.ctx.strokeStyle = obj.currentSpeed > speedThreshold ? 'red' : 'lime';
        this.ctx.stroke();
        this.ctx.fillStyle = obj.currentSpeed > speedThreshold ? 'red' : 'lime';
        this.ctx.font = '16px Arial';
        this.ctx.fillText(`${obj.class} ID:${obj.id}`, drawX, drawY - 10);
        this.ctx.fillText(`${obj.currentSpeed.toFixed(1)} km/h`, drawX, drawY + drawHeight + 20);
      });
    }

    startRecordingViolation(vehicleId, speedKmH) {
      if (this.recording) return; // Already recording a violation

      this.recording = true;
      this.recordingIndicator.style.display = 'block';
      this.recordedChunks = [];

      const stream = this.canvas.captureStream(30); // 30 FPS
      this.mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp8' });

      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.recordedChunks.push(event.data);
        }
      };

      this.mediaRecorder.onstop = () => {
        const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
        saveViolationRecording(this.id, vehicleId, speedKmH, blob);
        this.recording = false;
        this.recordingIndicator.style.display = 'none';
        this.currentViolation = null;
      };

      this.mediaRecorder.start();
      this.currentViolation = { vehicleId, speedKmH };

      // Stop recording after 5 seconds
      setTimeout(() => {
        if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
          this.mediaRecorder.stop();
        }
      }, 5000);
    }
    
    remove() {
      this.stopStream();
      this.container.remove();
      allCameras = allCameras.filter(cam => cam.id !== this.id);
      addLogEntry(`Camera ${this.id+1} removed.`);
    }
  }

  // Event Listeners
  addCameraBtn.addEventListener('click', () => {
    if (allCameras.length >= MAX_CAMERAS) {
      showCustomMessageBox(`Maximum of ${MAX_CAMERAS} cameras supported.`);
      return;
    }
    const url = newCamUrl.value.trim();
    if (url) {
      const newCam = new Camera(allCameras.length, url);
      allCameras.push(newCam);
      newCamUrl.value = '';
    } else {
      showCustomMessageBox("Please enter a camera stream URL.");
    }
  });

  speedThresholdInput.addEventListener('input', () => {
    speedThreshold = parseInt(speedThresholdInput.value);
    speedValSpan.textContent = speedThreshold;
    addLogEntry(`Speed limit set to ${speedThreshold} km/h.`);
  });

  fpsControl.addEventListener('change', () => {
    frameInterval = parseInt(fpsControl.value);
    addLogEntry(`Processing rate set to ${1000 / frameInterval} FPS.`);
    allCameras.forEach(cam => {
      if (cam.streaming) {
        cam.stopStream();
        cam.startStream(); // Restart stream with new FPS
      }
    });
  });

  clearLogBtn.addEventListener('click', () => {
    logDiv.innerHTML = `
      <div class="log-entry">
        <div class="log-timestamp">[System Startup]</div>
        <div class="log-message">Multi-Stream Speed Detection System initialized. Add cameras to begin.</div>
      </div>
      <div class="log-entry">
        <div class="log-timestamp">[System Info]</div>
        <div class="log-message">Violation videos will be validated before download.</div>
      </div>
    `;
    addLogEntry("Detection log cleared.");
  });

  resetBtn.addEventListener('click', () => {
    // Using a custom confirmation box
    showCustomConfirmBox("Are you sure you want to reset all cameras and recordings?", () => {
        allCameras.forEach(cam => cam.remove());
        allCameras = [];
        recordings = [];
        recordingsList.innerHTML = '';
        logDiv.innerHTML = `
            <div class="log-entry">
                <div class="log-timestamp">[System Startup]</div>
                <div class="log-message">Multi-Stream Speed Detection System initialized. Add cameras to begin.</div>
            </div>
            <div class="log-entry">
                <div class="log-timestamp">[System Info]</div>
                <div class="log-message">Violation videos will be validated before download.</div>
            </div>
        `;
        calibrationPoints = [];
        if (lineElement) {
            lineElement.remove();
            lineElement = null;
        }
        calibrationResult.textContent = '0.0333';
        addLogEntry("System reset. All cameras and recordings cleared.");
    });
  });

  // Calibration Logic
  calibrationGrid.addEventListener('click', (e) => {
    if (calibrationPoints.length < 2) {
      const rect = calibrationGrid.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      calibrationPoints.push({ x, y });

      const pointDiv = document.createElement('div');
      pointDiv.className = 'calibration-point';
      pointDiv.style.left = `${x}px`;
      pointDiv.style.top = `${y}px`;
      calibrationGrid.appendChild(pointDiv);

      if (calibrationPoints.length === 2) {
        drawLineBetweenPoints();
        addLogEntry("Two calibration points set. Click 'Calculate' to determine pixel-to-meter ratio.");
      } else {
        addLogEntry("First calibration point set. Click again to set the second point.");
      }
    } else {
      showCustomMessageBox("Calibration points already set. Click 'Calculate' or reset to set new points.");
    }
  });

  function drawLineBetweenPoints() {
    if (calibrationPoints.length === 2) {
      if (lineElement) {
        lineElement.remove();
      }
      lineElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      lineElement.style.position = 'absolute';
      lineElement.style.top = '0';
      lineElement.style.left = '0';
      lineElement.style.width = '100%';
      lineElement.style.height = '100%';
      lineElement.style.pointerEvents = 'none';

      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', calibrationPoints[0].x);
      line.setAttribute('y1', calibrationPoints[0].y);
      line.setAttribute('x2', calibrationPoints[1].x);
      line.setAttribute('y2', calibrationPoints[1].y);
      line.setAttribute('stroke', 'yellow');
      line.setAttribute('stroke-width', '2');
      line.setAttribute('stroke-dasharray', '5,5');
      lineElement.appendChild(line);
      calibrationGrid.appendChild(lineElement);
    }
  }

  calcCalibrationBtn.addEventListener('click', () => {
    if (calibrationPoints.length === 2) {
      const p1 = calibrationPoints[0];
      const p2 = calibrationPoints[1];
      const pixelDistance = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
      const refDist = parseFloat(refDistanceInput.value);

      if (pixelDistance > 0 && refDist > 0) {
        pixelToMeter = refDist / pixelDistance;
        calibrationResult.textContent = pixelToMeter.toFixed(4);
        addLogEntry(`Calibration calculated: 1 pixel = ${pixelToMeter.toFixed(4)} meters.`);
      } else {
        showCustomMessageBox("Please set valid calibration points and a reference distance.");
      }
    } else {
      showCustomMessageBox("Please set two calibration points first.");
    }
  });

  // Validation Modal Event Listeners
  closeValidation.addEventListener('click', () => {
    validationModal.classList.remove('active');
    if (validationVideo) {
      validationVideo.pause();
      validationVideo.src = '';
      URL.revokeObjectURL(validationVideo.src);
    }
  });

  cancelDownload.addEventListener('click', () => {
    validationModal.classList.remove('active');
    if (validationVideo) {
      validationVideo.pause();
      validationVideo.src = '';
      URL.revokeObjectURL(validationVideo.src);
    }
    addLogEntry("Video validation cancelled by user.");
  });

  confirmDownload.addEventListener('click', () => {
    if (currentValidation) {
      downloadRecording(currentValidation);
    }
  });

  downloadValidated.addEventListener('click', () => {
    if (currentValidation) {
      downloadRecording(currentValidation);
    }
  });

  // Custom Message Box Functionality (replaces alert and confirm)
  function showCustomMessageBox(message) {
      // Create a simple modal or div for messages
      const messageBox = document.createElement('div');
      messageBox.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(30, 30, 46, 0.95);
          border-radius: 15px;
          padding: 30px;
          box-shadow: 0 15px 50px rgba(0, 0, 0, 0.5);
          border: 1px solid rgba(92, 119, 179, 0.5);
          color: white;
          z-index: 1001;
          text-align: center;
          max-width: 400px;
      `;
      messageBox.innerHTML = `
          <p style="margin-bottom: 20px; font-size: 1.1rem;">${message}</p>
          <button class="btn" style="padding: 8px 20px;" onclick="this.parentNode.remove()">OK</button>
      `;
      document.body.appendChild(messageBox);
  }

  function showCustomConfirmBox(message, onConfirm) {
      const confirmBox = document.createElement('div');
      confirmBox.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(30, 30, 46, 0.95);
          border-radius: 15px;
          padding: 30px;
          box-shadow: 0 15px 50px rgba(0, 0, 0, 0.5);
          border: 1px solid rgba(92, 119, 179, 0.5);
          color: white;
          z-index: 1001;
          text-align: center;
          max-width: 400px;
      `;
      confirmBox.innerHTML = `
          <p style="margin-bottom: 20px; font-size: 1.1rem;">${message}</p>
          <button class="btn btn-danger" style="margin-right: 10px; padding: 8px 20px;" id="confirmYes">Yes</button>
          <button class="btn btn-secondary" style="padding: 8px 20px;" id="confirmNo">No</button>
      `;
      document.body.appendChild(confirmBox);

      document.getElementById('confirmYes').onclick = () => {
          onConfirm();
          confirmBox.remove();
      };
      document.getElementById('confirmNo').onclick = () => {
          confirmBox.remove();
      };
  }

</script>
</body>
</html>
